-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParReBabel where
import AbsReBabel
import LexReBabel
import ErrM

}

%name pProgram Program
%name pFFalse FFalse
%name pTTrue TTrue
%name pTrueInteger TrueInteger
%name pRawCondition RawCondition
%name pCondition Condition
%name pOperator Operator
%name pExpr Expr
%name pListStmt ListStmt
%name pStmt Stmt
%name pBlock Block
%name pRBlock RBlock
%name pRStmt RStmt
%name pType Type
%name pListType ListType
%name pListIdent ListIdent
%name pListItem ListItem
%name pTypeDecl TypeDecl
%name pListTypeDecl ListTypeDecl
%name pLambda Lambda
%name pItem Item
%name pRefOrVal RefOrVal
%name pListRefOrVal ListRefOrVal
%name pCall Call
%name pBOperator BOperator
%name pMathOp MathOp
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '->' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ';' { PT _ (TS _ 9) }
  '<' { PT _ (TS _ 10) }
  '=' { PT _ (TS _ 11) }
  '==' { PT _ (TS _ 12) }
  '>' { PT _ (TS _ 13) }
  'and' { PT _ (TS _ 14) }
  'bool' { PT _ (TS _ 15) }
  'call' { PT _ (TS _ 16) }
  'done' { PT _ (TS _ 17) }
  'else' { PT _ (TS _ 18) }
  'false' { PT _ (TS _ 19) }
  'function' { PT _ (TS _ 20) }
  'if' { PT _ (TS _ 21) }
  'int' { PT _ (TS _ 22) }
  'lambda' { PT _ (TS _ 23) }
  'neither' { PT _ (TS _ 24) }
  'not' { PT _ (TS _ 25) }
  'or' { PT _ (TS _ 26) }
  'ref' { PT _ (TS _ 27) }
  'return' { PT _ (TS _ 28) }
  'shout' { PT _ (TS _ 29) }
  'string' { PT _ (TS _ 30) }
  'this' { PT _ (TS _ 31) }
  'true' { PT _ (TS _ 32) }
  'val' { PT _ (TS _ 33) }
  'void' { PT _ (TS _ 34) }
  'while' { PT _ (TS _ 35) }
  'xor' { PT _ (TS _ 36) }
  '{' { PT _ (TS _ 37) }
  '}' { PT _ (TS _ 38) }

L_integ  { PT _ (TI $$) }
L_ident  { PT _ (TV $$) }
L_quoted { PT _ (TL $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Ident   :: { Ident }   : L_ident  { Ident $1 }
String  :: { String }  : L_quoted {  $1 }

Program :: { Program }
Program : ListStmt { AbsReBabel.Program $1 }
FFalse :: { FFalse }
FFalse : 'false' { AbsReBabel.FFalse }
TTrue :: { TTrue }
TTrue : 'true' { AbsReBabel.TTrue }
TrueInteger :: { TrueInteger }
TrueInteger : Integer { AbsReBabel.Positive $1 }
            | '-' Integer { AbsReBabel.Negative $2 }
RawCondition :: { RawCondition }
RawCondition : TTrue { AbsReBabel.TrueCond $1 }
             | FFalse { AbsReBabel.FFalseCond $1 }
             | Condition BOperator Condition { AbsReBabel.BExpr $1 $2 $3 }
             | Item '==' Item { AbsReBabel.Equal $1 $3 }
             | Item '>' Item { AbsReBabel.Greater $1 $3 }
             | Item '<' Item { AbsReBabel.Smaller $1 $3 }
             | 'not' Condition { AbsReBabel.Negate $2 }
Condition :: { Condition }
Condition : '(' RawCondition ')' { AbsReBabel.Cond $2 }
Operator :: { Operator }
Operator : '(' Type ')' Ident '(' Type ')' '=' Lambda { AbsReBabel.DefineOperator $2 $4 $6 $9 }
Expr :: { Expr }
Expr : Item Operator Item { AbsReBabel.CallOperator $1 $2 $3 }
     | Call { AbsReBabel.ECall $1 }
     | Item MathOp Item { AbsReBabel.MathExpr $1 $2 $3 }
ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] }
         | Stmt { (:[]) $1 }
         | Stmt ';' ListStmt { (:) $1 $3 }
Stmt :: { Stmt }
Stmt : ';' { AbsReBabel.Empty }
     | Block { AbsReBabel.BlockStatement $1 }
     | Type Ident { AbsReBabel.Decl $1 $2 }
     | Ident '=' Item { AbsReBabel.Ass $1 $3 }
     | 'if' Condition Block 'else' Block { AbsReBabel.IfStmt $2 $3 $5 }
     | 'while' Condition Block { AbsReBabel.WhileStmt $2 $3 }
     | 'shout' Item { AbsReBabel.PrintStatement $2 }
     | Call { AbsReBabel.CallStmt $1 }
Block :: { Block }
Block : '{' ListStmt '}' { AbsReBabel.Block $2 }
RBlock :: { RBlock }
RBlock : '{' ListStmt RStmt '}' { AbsReBabel.ReturnBlock $2 $3 }
RStmt :: { RStmt }
RStmt : RBlock { AbsReBabel.RBlockStatement $1 }
      | 'return' Item { AbsReBabel.Return $2 }
      | 'done' { AbsReBabel.VoidReturn }
      | 'if' Condition RBlock 'else' RBlock { AbsReBabel.RIfStmt $2 $3 $5 }
Type :: { Type }
Type : 'void' { AbsReBabel.VoidT }
     | 'int' { AbsReBabel.IntT }
     | 'bool' { AbsReBabel.BoolT }
     | 'string' { AbsReBabel.StringT }
     | 'function' '(' ListType ')' '->' '(' Type ')' { AbsReBabel.FunctionT $3 $7 }
ListType :: { [Type] }
ListType : Type { (:[]) $1 } | Type ',' ListType { (:) $1 $3 }
ListIdent :: { [Ident] }
ListIdent : Ident { (:[]) $1 } | Ident ',' ListIdent { (:) $1 $3 }
ListItem :: { [Item] }
ListItem : Item { (:[]) $1 } | Item ',' ListItem { (:) $1 $3 }
TypeDecl :: { TypeDecl }
TypeDecl : Type Ident { AbsReBabel.TypeDecl $1 $2 }
ListTypeDecl :: { [TypeDecl] }
ListTypeDecl : TypeDecl { (:[]) $1 }
             | TypeDecl ',' ListTypeDecl { (:) $1 $3 }
Lambda :: { Lambda }
Lambda : 'lambda' ListTypeDecl '->' Type RBlock { AbsReBabel.Lambda $2 $4 $5 }
Item :: { Item }
Item : Expr { AbsReBabel.ItemExpr $1 }
     | '(' Item ')' { AbsReBabel.BracesItem $2 }
     | Ident { AbsReBabel.ItemIdent $1 }
     | TrueInteger { AbsReBabel.ItemLiteral $1 }
     | String { AbsReBabel.ItemString $1 }
     | Lambda { AbsReBabel.ItemLambda $1 }
     | 'this' { AbsReBabel.ThisFunctionLambda }
RefOrVal :: { RefOrVal }
RefOrVal : 'ref' Ident { AbsReBabel.Ref $2 }
         | 'val' Item { AbsReBabel.Val $2 }
ListRefOrVal :: { [RefOrVal] }
ListRefOrVal : {- empty -} { [] }
             | RefOrVal { (:[]) $1 }
             | RefOrVal ',' ListRefOrVal { (:) $1 $3 }
Call :: { Call }
Call : 'call' Item ListRefOrVal { AbsReBabel.Call $2 $3 }
BOperator :: { BOperator }
BOperator : 'and' { AbsReBabel.And }
          | 'or' { AbsReBabel.Or }
          | 'neither' { AbsReBabel.Neither }
          | 'xor' { AbsReBabel.Xor }
MathOp :: { MathOp }
MathOp : '+' { AbsReBabel.Add }
       | '-' { AbsReBabel.Sub }
       | '*' { AbsReBabel.Mul }
       | '/' { AbsReBabel.Div }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

